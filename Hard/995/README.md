# K 连续位的最小翻转次数
## 在仅包含 0 和 1 的数组 A 中，一次 K 位翻转包括选择一个长度为 K 的（连续）子数组，同时将子数组中的每个 0 更改为 1，而每个 1 更改为 0。  
返回所需的 K 位翻转的最小次数，以便数组没有值为 0 的元素。如果不可能，返回 -1。
## 示例   
1:  
输入：A = [0,1,0], K = 1   
输出：2   
解释：先翻转 A[0]，然后翻转 A[2]。   
2:  
输入：A = [1,1,0], K = 2  
输出：-1  
解释：无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。  
3:  
输入：A = [0,0,0,1,0,1,1,0], K = 3  
输出：3  
解释：  
翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]  
翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]   
翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]  
## 解题思路  
step 1:  
第一步容易想到的是如果每一次要翻动K位连续子数组，那么在这个长度为K的滑动窗口滑动过程中，每一个窗口会决定该窗口第一位的最终数值，那么要求翻动的最小次数，就需要顺序将每一位作为滑动窗口的第一位进行判断。  
于是有了第一种时间复杂度为O(KN)的算法，即顺序执行，每次对其余K-1位翻转，但这种方法在提交过程中会超时。  
Step 2:  
第一步的算法中最耗时的部分是翻转，所以我们得想办法缩减这部分翻转造成的时间损耗。于是想到用统计每位需要翻转的次数代替翻转的方法。但如果新建一个数组直接记录翻转次数（即遇到一个滑动窗口，将该窗口其余的  
K-1个次数加一，其时间复杂度也位O(KN)。为了解决这个问题，我们维护一个当前翻转次数，从题目描述中可以看出，当第一位需要翻转时，这次翻转会持续K位，即当i+K位才会不受这次翻转影响，所以我们在数组中记录  
不受影响的这位，具体做法是每次当第一位需要翻转是，将当前翻转次数加1，但同时将i+K位的数组值置为-1（该数组初始值皆为0）。算法在每次判断当前位时会先同数组中记录的值相加，这样，就可以使每一位的翻转作用  
域在[i,i+k-1]中。  
Step 3:  
第二步的做法的缺陷是需要一个额外的复杂度为O(N)的空间。优化方法是在原数组中引入一个范围外的值，具体来说，原数组中只会出现0，1两种情况，这时候我们只要引入2作为标识符即可。
